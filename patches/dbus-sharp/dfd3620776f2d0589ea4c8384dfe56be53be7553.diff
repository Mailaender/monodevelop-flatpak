diff --git a/src/Authentication.cs b/src/Authentication.cs
index cd23945..714a3b6 100644
--- a/src/Authentication.cs
+++ b/src/Authentication.cs
@@ -357,8 +357,6 @@ public override IEnumerator<AuthCommand> GetEnumerator ()
 					throw new Exception ("Authentication failure");
 				}
 
-				Peer.isFinalRead = true;
-
 				AuthCommand reply;
 				if (!replies.MoveNext ())
 					yield break;
@@ -387,6 +385,23 @@ public override IEnumerator<AuthCommand> GetEnumerator ()
 				else
 					ActualId = UUID.Parse (reply[1]);
 
+				if (SupportsUnixFileDescriptors) {
+					yield return new AuthCommand ("NEGOTIATE_UNIX_FD");
+
+					Peer.isFinalRead = true;
+
+					if (!replies.MoveNext ())
+						yield break;
+					reply = replies.Current;
+
+					if (reply.Value == "AGREE_UNIX_FD") {
+						SupportsUnixFileDescriptors = true;
+					} else {
+						SupportsUnixFileDescriptors = false;
+					}
+				} else {
+				}
+
 				yield return new AuthCommand ("BEGIN");
 				yield break;
 			}
@@ -394,6 +409,10 @@ public override IEnumerator<AuthCommand> GetEnumerator ()
 		}
 
 		public UUID ActualId = UUID.Zero;
+		//flat to indicate if we support unix file descriptors
+		//TODO: this should be passed to the connection, and checked when reading/writing objects and 
+		//throw an exception if attempting to pass a Stream and the connection does not support it
+		public bool SupportsUnixFileDescriptors;
 	}
 
 	class SaslServer : SaslPeer
diff --git a/src/Connection.cs b/src/Connection.cs
index 4a18033..05fcb03 100644
--- a/src/Connection.cs
+++ b/src/Connection.cs
@@ -41,6 +41,8 @@ public class Connection
 		public delegate void MonitorEventHandler (Message msg);
 		public MonitorEventHandler Monitors; // subscribe yourself to this list of observers if you want to get notified about each incoming message
 
+		public bool SupportsUnixFileDescriptors{ get; private set; }
+
 		protected Connection ()
 		{
 
@@ -150,6 +152,7 @@ void Authenticate ()
 			auth.Peer = new SaslPeer ();
 			auth.Peer.Peer = auth;
 			auth.Peer.stream = transport.Stream;
+			auth.SupportsUnixFileDescriptors = true;
 
 			if (!auth.Authenticate ())
 				throw new Exception ("Authentication failure");
@@ -162,6 +165,7 @@ void Authenticate ()
 				Id = auth.ActualId;
 
 			isAuthenticated = true;
+			this.SupportsUnixFileDescriptors = auth.SupportsUnixFileDescriptors;
 		}
 
 		// Interlocked.Increment() handles the overflow condition for uint correctly,
@@ -259,8 +263,8 @@ internal virtual void HandleMessage (Message msg)
 			}
 
 			switch (msg.Header.MessageType) {
-				case MessageType.MethodCall:
-					MessageContainer method_call = MessageContainer.FromMessage (msg);
+			case MessageType.MethodCall:
+				MessageContainer method_call = MessageContainer.FromMessage (msg);
 					HandleMethodCall (method_call);
 					break;
 				case MessageType.Signal:
diff --git a/src/FileDescriptor.cs b/src/FileDescriptor.cs
new file mode 100644
index 0000000..45bb5cd
--- /dev/null
+++ b/src/FileDescriptor.cs
@@ -0,0 +1,46 @@
+ï»¿using System;
+
+namespace DBus
+{
+	public class FileDescriptor:IDisposable
+	{
+		public int FD{get;private set;}
+		public bool Owns{ get; private set;}
+		public FileDescriptor (int fd)
+		{
+			FD=fd;
+			Owns = true;
+		}
+
+		//Do we expose Unix.Stream or just the generic IO.Stream?  Decisions...
+		public /*Mono.Unix.Unix*/System.IO.Stream OpenAsStream(bool transferOwnership)
+		{
+			var stream = new Mono.Unix.UnixStream (FD, transferOwnership);
+			Owns = !transferOwnership;
+			return stream;
+		}
+
+		//TODO: move this somewhere better
+		public void SetBlocking()
+		{
+			Mono.Unix.Native.Syscall.fcntl(FD
+				,Mono.Unix.Native.FcntlCommand.F_SETFL
+				,Mono.Unix.Native.Syscall.fcntl(FD,
+					Mono.Unix.Native.FcntlCommand.F_GETFL,0)
+				^ (int)Mono.Unix.Native.OpenFlags.O_NONBLOCK);
+		}
+
+		public void Close()
+		{
+			Mono.Unix.Native.Syscall.close (FD);
+		}
+
+		public void Dispose()
+		{
+			if (Owns) {
+				Close ();
+			}
+		}
+	}
+}
+
diff --git a/src/Protocol/DType.cs b/src/Protocol/DType.cs
index e14c99f..f7d8d35 100644
--- a/src/Protocol/DType.cs
+++ b/src/Protocol/DType.cs
@@ -24,6 +24,7 @@ public enum DType : byte
 		String = (byte)'s',
 		ObjectPath = (byte)'o',
 		Signature = (byte)'g',
+		UnixFileDescriptor = (byte)'h',
 
 		Array = (byte)'a',
 		Variant = (byte)'v',
diff --git a/src/Protocol/FieldCode.cs b/src/Protocol/FieldCode.cs
index a524df2..ec1ed2b 100644
--- a/src/Protocol/FieldCode.cs
+++ b/src/Protocol/FieldCode.cs
@@ -18,6 +18,7 @@ public enum FieldCode : byte
 		Destination,
 		Sender,
 		Signature,
+		UnixFds,
 #if PROTO_REPLY_SIGNATURE
 		ReplySignature, //note: not supported in dbus
 #endif
diff --git a/src/Protocol/Message.cs b/src/Protocol/Message.cs
index cbaeb65..0ebf38a 100644
--- a/src/Protocol/Message.cs
+++ b/src/Protocol/Message.cs
@@ -100,5 +100,7 @@ public byte[] GetHeaderData ()
 			header.WriteHeaderToMessage (writer);
 			return writer.ToArray ();
 		}
+
+		public int[] UnixFDS{get;set;}
 	}
 }
diff --git a/src/Protocol/MessageReader.cs b/src/Protocol/MessageReader.cs
index 1670df5..54dc361 100644
--- a/src/Protocol/MessageReader.cs
+++ b/src/Protocol/MessageReader.cs
@@ -72,6 +72,13 @@ public MessageReader (Message message) : this (message.Header.Endianness, messag
 			}
 		}
 
+		public IEnumerable<object> ReadValues ()
+		{
+			for (int i = 0; i < message.Signature.Length; ++i) {
+				yield return ReadValue (message.Signature[i]);
+			}
+		}
+
 		public object ReadValue (Type type)
 		{
 			if (type == typeof (void))
@@ -87,6 +94,9 @@ public object ReadValue (Type type)
 			} else if (type == typeof (ObjectPath)) {
 				readValueCache[type] = () => ReadObjectPath ();
 				return ReadObjectPath ();
+			} else if (type == typeof (FileDescriptor)) {
+				readValueCache[type] = () => ReadFileDescriptor();
+				return ReadFileDescriptor();
 			} else if (type == typeof (Signature)) {
 				readValueCache[type] = () => ReadSignature ();
 				return ReadSignature ();
@@ -96,7 +106,9 @@ public object ReadValue (Type type)
 			} else if (type == typeof (string)) {
 				readValueCache[type] = () => ReadString ();
 				return ReadString ();
-			} else if (type.IsGenericType && (type.GetGenericTypeDefinition () == typeof (Dictionary<,>) || type.GetGenericTypeDefinition() == typeof(IDictionary<,>))) {
+			} else if (type.IsGenericType 
+					&& (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(Dictionary<,>)) 
+					|| type.GetGenericTypeDefinition().IsAssignableFrom(typeof(IDictionary<,>)))) {
 				Type[] genArgs = type.GetGenericArguments ();
 				readValueCache[type] = () => ReadDictionary (genArgs[0], genArgs[1]);
 				return ReadDictionary (genArgs[0], genArgs[1]);
@@ -166,6 +178,9 @@ public object ReadValue (DType dtype)
 				case DType.Variant:
 					return ReadVariant ();
 
+				case DType.UnixFileDescriptor:
+				return ReadFileDescriptor();
+
 				default:
 					throw new Exception ("Unhandled D-Bus type: " + dtype);
 			}
@@ -364,6 +379,37 @@ public ObjectPath ReadObjectPath ()
 			return new ObjectPath (ReadString ());
 		}
 
+		public FileDescriptor ReadFileDescriptor ()
+		{
+			int fdIndex = ReadInt32 ();
+			if (message.Connection.SupportsUnixFileDescriptors) {
+				object count;
+				if (message.Header.TryGetField (FieldCode.UnixFds, out count)) {
+					//System.Console.WriteLine ("FD Count " + count+","+count.GetType());
+					if ((uint)fdIndex >= ((uint)count)) {
+						throw new IndexOutOfRangeException ("Specified file descriptor index is outside the range of supplied file descriptors");
+					} else if (message.UnixFDS != null && fdIndex < message.UnixFDS.Length) {
+						int fd = message.UnixFDS [fdIndex];
+
+						var descriptor = new FileDescriptor (fd);
+						return descriptor;
+					} 
+					else 
+					{
+						throw new Exception("No file descriptors read from control message");
+					}
+				} else {
+					throw new Exception ("Missing file descriptors");
+				}
+			} 
+			else 
+			{
+				//would it be better to return a "special" file descriptor that indicates it's not supported
+				//that way the rest of the params can come through?
+				throw new NotSupportedException ("The current connection does not support unix file descriptors");
+			}
+		}
+
 		public Signature ReadSignature ()
 		{
 			byte ln = ReadByte ();
@@ -479,12 +525,12 @@ TArray[] MarshalArray<TArray> (uint length)
 
 			if (endianness == Connection.NativeEndianness) {
 				Buffer.BlockCopy (data, pos, array, 0, (int)length);
+				pos += (int)length;
 			} else {
 				GCHandle handle = GCHandle.Alloc (array, GCHandleType.Pinned);
 				DirectCopy (sof, length, handle);
 				handle.Free ();
 			}
-			pos += (int)length;
 
 			return array;
 		}
@@ -504,6 +550,8 @@ unsafe void DirectCopy (int sof, uint length, IntPtr handle)
 					for (int j = i; j < i + sof; j++)
 						ptr[2 * i - pos + (sof - 1) - j] = data[j];
 			}
+
+			pos += (int)length /** sof*/;
 		}
 
 		bool[] MarshalBoolArray (uint length)
@@ -562,9 +610,7 @@ object MarshalStruct (Type structType, FieldInfo[] fis)
 			object strct = Activator.CreateInstance (structType);
 			int sof = Marshal.SizeOf (fis[0].FieldType);
 			GCHandle handle = GCHandle.Alloc (strct, GCHandleType.Pinned);
-			uint length = (uint)(fis.Length * sof);
-			DirectCopy (sof, length, handle);
-			pos += (int)length;
+			DirectCopy (sof, (uint)(fis.Length * sof), handle);
 			handle.Free ();
 
 			return strct;
diff --git a/src/Protocol/MessageWriter.cs b/src/Protocol/MessageWriter.cs
index 11f5329..d127ca8 100644
--- a/src/Protocol/MessageWriter.cs
+++ b/src/Protocol/MessageWriter.cs
@@ -201,6 +201,8 @@ public void Write (Type type, object val)
 				mi.Invoke (this, new object[] {val});
 			} else if (type == typeof (ObjectPath)) {
 				Write ((ObjectPath)val);
+			} else if (type == typeof (FileDescriptor)) {
+				Write((FileDescriptor)val);
 			} else if (type == typeof (Signature)) {
 				Write ((Signature)val);
 			} else if (type == typeof (object)) {
@@ -221,6 +223,21 @@ public void Write (Type type, object val)
 			}
 		}
 
+		public void Write(FileDescriptor fd)
+		{
+
+			if (Connection.SupportsUnixFileDescriptors) {
+				int index = 0;
+				//TODO: if the transport supports it, add the FD to the socket control message
+				//and return the index
+				//insert the relevant index instead of the handle itself
+				//also increment the unixfds field count in the header
+				Write(DType.UnixFileDescriptor,index);
+			} else {
+				throw new NotSupportedException("Current connection does not support passing unix file descriptors");
+			}
+		}
+
 		//helper method, should not be used as it boxes needlessly
 		public void Write (DType dtype, object val)
 		{
@@ -293,11 +310,16 @@ public void Write (DType dtype, object val)
 					Write ((Signature)val);
 				}
 				break;
-				case DType.Variant:
+			case DType.Variant:
 				{
 					Write ((object)val);
 				}
 				break;
+			case DType.UnixFileDescriptor:
+				{
+					Write ((FileDescriptor)val);
+				}
+				break;
 				default:
 				throw new Exception ("Unhandled D-Bus type: " + dtype);
 			}
@@ -500,6 +522,7 @@ internal void WriteHeaderFields (Dictionary<byte, object> val)
 						Write (Signature.UInt32Sig);
 						Write ((uint)entry.Value);
 						break;
+					//TODO: Add FieldCode.UnixFDs
 					default:
 						Write (entry.Value);
 						break;
diff --git a/src/Protocol/ProtocolInformation.cs b/src/Protocol/ProtocolInformation.cs
index 2747516..1304ddd 100644
--- a/src/Protocol/ProtocolInformation.cs
+++ b/src/Protocol/ProtocolInformation.cs
@@ -76,6 +76,8 @@ public static int GetAlignment (DType dtype)
 					return 1;
 				case DType.DictEntryBegin:
 					return 8;
+				case DType.UnixFileDescriptor:
+					return 4;//note that this refers to the length of the INDEX to the FD, not the FD itself
 				case DType.Invalid:
 				default:
 					throw new Exception ("Cannot determine alignment of " + dtype);
diff --git a/src/Protocol/Signature.cs b/src/Protocol/Signature.cs
index 66336be..21214ae 100644
--- a/src/Protocol/Signature.cs
+++ b/src/Protocol/Signature.cs
@@ -8,6 +8,7 @@
 using System.Collections.Generic;
 //TODO: Reflection should be done at a higher level than this class
 using System.Reflection;
+using System.IO;
 
 namespace DBus.Protocol
 {
@@ -30,6 +31,7 @@ public struct Signature
 		public static readonly Signature ObjectPathSig = Allocate (DType.ObjectPath);
 		public static readonly Signature SignatureSig = Allocate (DType.Signature);
 		public static readonly Signature VariantSig = Allocate (DType.Variant);
+		public static readonly Signature UnixFileDescriptorSig = Allocate (DType.UnixFileDescriptor);
 
 		public static bool operator == (Signature a, Signature b)
 		{
@@ -182,6 +184,8 @@ static byte[] DataForDType (DType value)
 					return SignatureSig.data;
 				case DType.Variant:
 					return VariantSig.data;
+				case DType.UnixFileDescriptor:
+					return UnixFileDescriptorSig.data;
 				default:
 					return new byte[] {(byte)value};
 			}
@@ -332,6 +336,8 @@ static int GetSize (DType dtype)
 				case DType.Variant:
 				case DType.DictEntryBegin:
 					return -1;
+				case DType.UnixFileDescriptor:
+					return 4;
 				case DType.Invalid:
 				default:
 					throw new Exception ("Cannot determine size of " + dtype);
@@ -620,6 +626,9 @@ internal static DType TypeToDType (Type type)
 			if (type == typeof (ObjectPath))
 				return DType.ObjectPath;
 
+			if (type == typeof (FileDescriptor))
+				return DType.UnixFileDescriptor;
+
 			if (type == typeof (Signature))
 				return DType.Signature;
 
@@ -636,9 +645,6 @@ internal static DType TypeToDType (Type type)
 			if (type.IsArray)
 				return DType.Array;
 
-			if (type.IsGenericType && (type.GetGenericTypeDefinition() == typeof(IDictionary<,>) || type.GetGenericTypeDefinition() == typeof(Dictionary<,>)))
-				return DType.Array;
-
 			//if (type.UnderlyingSystemType != null)
 			//	return TypeToDType (type.UnderlyingSystemType);
 			if (Mapper.IsPublic (type))
@@ -795,6 +801,8 @@ public Type ToType (ref int pos)
 				return typeof (string);
 			case DType.ObjectPath:
 				return typeof (ObjectPath);
+			case DType.UnixFileDescriptor:
+				return typeof(FileDescriptor);
 			case DType.Signature:
 				return typeof (Signature);
 			case DType.Array:
@@ -856,6 +864,9 @@ public static Signature GetSig (Type type)
 			if (type == typeof (ObjectPath))
 				return Signature.ObjectPathSig;
 
+			if (type == typeof(FileDescriptor))
+				return Signature.UnixFileDescriptorSig;
+
 			if (type == typeof (void))
 				return Signature.Empty;
 
@@ -927,6 +938,7 @@ bool SingleType ()
 				case DType.Double:
 				case DType.String:
 				case DType.ObjectPath:
+				case DType.UnixFileDescriptor:
 				case DType.Signature:
 				case DType.Variant:
 					pos += 1;
diff --git a/src/Protocol/SocketTransport.cs b/src/Protocol/SocketTransport.cs
index aa3a3a4..7222b2e 100644
--- a/src/Protocol/SocketTransport.cs
+++ b/src/Protocol/SocketTransport.cs
@@ -68,5 +68,6 @@ public override string AuthString ()
 				Mono.Unix.Native.Syscall.geteuid ().ToString ()                       // Unix User ID
 				: System.Security.Principal.WindowsIdentity.GetCurrent ().User.Value; // Windows User ID
 		}
+
 	}
 }
diff --git a/src/Protocol/Transport.cs b/src/Protocol/Transport.cs
index 2ae8815..40d9d3d 100644
--- a/src/Protocol/Transport.cs
+++ b/src/Protocol/Transport.cs
@@ -16,7 +16,12 @@ abstract class Transport
 		readonly object writeLock = new object ();
 
 		[ThreadStatic]
+		public Unix.ReceivedMessage message;
+		[ThreadStatic]
 		static byte[] readBuffer;
+		[ThreadStatic]
+		static int pos;
+
 
 		protected Connection connection;
 
@@ -151,39 +156,80 @@ internal Message ReadMessage ()
 		{
 			Message msg;
 
-			try {
-				msg = ReadMessageReal ();
-			} catch (IOException e) {
-				if (ProtocolInformation.Verbose)
-					Console.Error.WriteLine (e.Message);
-				connection.IsConnected = false;
-				msg = null;
-			}
+				try {
+					msg = ReadMessageReal ();
+				} catch (/*IO*/Exception e) {
+					if (ProtocolInformation.Verbose)
+						Console.Error.WriteLine (e.Message);
+					connection.IsConnected = false;
+					msg = null;
+				}
          
-			if (connection != null && connection.Monitors != null)
-				connection.Monitors (msg);
+				if (connection != null && connection.Monitors != null)
+					connection.Monitors (msg);
+
+				return msg;
 
-			return msg;
 		}
 
 		int Read (byte[] buffer, int offset, int count)
 		{
-			int read = 0;
-			while (read < count) {
-				int nread = stream.Read (buffer, offset + read, count - read);
-				if (nread == 0)
-					break;
-				read += nread;
-			}
+			//We have to use ReceiveMessage rather than read for fds
+			if (Connection.SupportsUnixFileDescriptors && stream is DBus.Unix.UnixStream) {
+				int read = 0;
+				if (message == null) {
+					message = ((Unix.UnixStream)stream).ReceiveMessage ();
+					pos = 0;
+				}
+
+				//TODO: clean this up into do-while
+				if (message != null) {
+					while (pos < message.Read && read < count) {
+						buffer [offset + read] = message.Message [pos];
+						read++;
+						pos++;
+					}
 
-			if (read > count)
-				throw new Exception ();
+					while (read < count) {
+						message = ((Unix.UnixStream)stream).ReceiveMessage ();
+						pos = 0;
+
+						if (message != null && message.Read >= 0) {
+							while (pos < message.Read && read < count) {
+								buffer [offset + read] = message.Message [pos];
+								read++;
+								pos++;
+							}
+						} 
+						else {
+							break;
+						}
+					}
+				}
 
-			return read;
+				return read;
+			} 
+			else 
+			{
+				System.Console.WriteLine ("Read(" + offset + "," + count + ")");
+				int read = 0;
+				while (read < count) {
+					int nread = stream.Read (buffer, offset + read, count - read);
+					if (nread == 0)
+						break;
+					read += nread;
+				}
+
+				if (read > count)
+					throw new Exception ();
+
+				return read;
+			}
 		}
 
 		Message ReadMessageReal ()
 		{
+
 			byte[] header = null;
 			byte[] body = null;
 
@@ -252,6 +298,11 @@ Message ReadMessageReal ()
 
 			Message msg = Message.FromReceivedBytes (Connection, header, body);
 
+			if (message != null 
+				&& message.FileDescriptors != null 
+				&& message.FileDescriptors.Length>0) {
+				msg.UnixFDS = message.FileDescriptors;
+			}
 			return msg;
 		}
 
@@ -259,6 +310,8 @@ internal virtual void WriteMessage (Message msg)
 		{
 			lock (writeLock) {
 				msg.Header.GetHeaderDataToStream (stream);
+				//TODO: extract file descriptors from msg and write them to the stream similiar to how we
+				//read them
 				if (msg.Body != null && msg.Body.Length != 0)
 					stream.Write (msg.Body, 0, msg.Body.Length);
 				stream.Flush ();
diff --git a/src/Transports/UnixNativeTransport.cs b/src/Transports/UnixNativeTransport.cs
index 8d6410f..940c64d 100644
--- a/src/Transports/UnixNativeTransport.cs
+++ b/src/Transports/UnixNativeTransport.cs
@@ -139,6 +139,7 @@ internal UnixSocket OpenAbstractUnix (string path)
 			client.Connect (sa);
 			return client;
 		}
+			
 	}
 
 #if HAVE_CMSGCRED
diff --git a/src/Unix/UnixSocket.cs b/src/Unix/UnixSocket.cs
index 93f6ad9..377707d 100644
--- a/src/Unix/UnixSocket.cs
+++ b/src/Unix/UnixSocket.cs
@@ -162,6 +162,20 @@ public void Close ()
 			connected = false;
 		}
 
+		public void Connect()
+		{
+			int r = 0;
+
+			do {
+				r = connect (Handle, null, 0);
+			} while (r < 0 && UnixError.ShouldRetry);
+
+			if (r < 0)
+				throw UnixError.GetLastUnixException ();
+
+			connected = true;
+		}
+
 		//TODO: consider memory management
 		public void Connect (byte[] remote_end)
 		{
@@ -233,8 +247,12 @@ unsafe public int Read (byte* bufP, int count)
 				r = (int)read (Handle, bufP, (SizeT)count);
 			} while (r < 0 && UnixError.ShouldRetry);
 
-			if (r < 0)
+			if (r < 0) {
+				var error = Marshal.GetLastWin32Error ();
+				System.Console.WriteLine ("Error " + error);
+
 				throw UnixError.GetLastUnixException ();
+			}
 
 			return r;
 		}
@@ -253,18 +271,70 @@ public int Write (byte* bufP, int count)
 			return r;
 		}
 
-		public int RecvMsg (void* bufP, int flags)
-		{
-			int r = 0;
-
-			do {
-				r = (int)recvmsg (Handle, bufP, flags);
-			} while (r < 0 && UnixError.ShouldRetry);
 
-			if (r < 0)
-				throw UnixError.GetLastUnixException ();
 
-			return r;
+		public ReceivedMessage RecvMsg ()
+		{
+//			int r = 0;
+//
+//			do {
+//				r = (int)recvmsg (Handle, bufP, flags);
+//			} while (r < 0 && UnixError.ShouldRetry);
+//
+//			if (r < 0)
+//				throw UnixError.GetLastUnixException ();
+//
+//			return r;
+
+			var buffer2 = new byte[1024*10];
+			var cmsg2 = new byte[1024*10];
+			var msghdr2 = new Mono.Unix.Native.Msghdr {
+				msg_control = cmsg2,
+				msg_controllen = cmsg2.Length,
+			};
+			var result = new ReceivedMessage ();
+			fixed (byte* ptr_buffer2 = buffer2) {
+				var iovecs2 = new Mono.Unix.Native.Iovec[] {
+					new Mono.Unix.Native.Iovec {
+						iov_base = (IntPtr) ptr_buffer2,
+						iov_len = (ulong) buffer2.Length,
+					},
+				};
+				msghdr2.msg_iov = iovecs2;
+				msghdr2.msg_iovlen = 1;
+				//System.Console.WriteLine ("recvmsg");
+				var ret = Mono.Unix.Native.Syscall.recvmsg (Handle, msghdr2,0);
+
+				if (ret ==-1)  {
+					var lastError = Marshal.GetLastWin32Error ();
+					System.Console.WriteLine ("Last error " + lastError);
+					System.Console.WriteLine ("Description" + Mono.Unix.UnixMarshal.GetErrorDescription((Mono.Unix.Native.Errno)lastError));
+					Mono.Unix.UnixMarshal.ThrowExceptionForLastError ();
+				}
+
+				result.Read = ret;
+				result.Message = buffer2;
+			}
+				
+			#if UNIXFDS
+			var fds = new global::System.Collections.Generic.List<int> ();
+			for (long offset = Mono.Unix.Native.Syscall.CMSG_FIRSTHDR (msghdr2); offset != -1; offset = Mono.Unix.Native.Syscall.CMSG_NXTHDR (msghdr2, offset)) {
+				var recvHdr = Mono.Unix.Native.Cmsghdr.ReadFromBuffer (msghdr2, offset);
+				var recvDataOffset = Mono.Unix.Native.Syscall.CMSG_DATA (msghdr2, offset);
+				var bytes = recvHdr.cmsg_len - (recvDataOffset - offset);
+				//Assert.AreEqual (bytes % sizeof (int), 0);
+				var fdCount = bytes / sizeof (int);
+				//System.Console.WriteLine("based on struct size, there should be "+fdCount+" fds");
+				fixed (byte* ptr = msghdr2.msg_control)
+				for (int i = 0; i < fdCount; i++)
+					fds.Add (((int*) (ptr + recvDataOffset))[i]);
+			}
+			if(fds.Count>0)
+			{
+				result.FileDescriptors = fds.ToArray ();
+			}
+			#endif
+			return result;
 		}
 
 		public int SendMsg (void* bufP, int flags)
@@ -328,4 +398,11 @@ public int Write (IOVector[] iov)
 		}
 
 	}
+
+	public class ReceivedMessage
+	{
+		public long Read;
+		public byte[] Message;
+		public int[] FileDescriptors;
+	}
 }
diff --git a/src/Unix/UnixStream.cs b/src/Unix/UnixStream.cs
index e3da624..9335f3a 100644
--- a/src/Unix/UnixStream.cs
+++ b/src/Unix/UnixStream.cs
@@ -85,6 +85,11 @@ public override int Read ([In, Out] byte[] buffer, int offset, int count)
 			return usock.Read (buffer, offset, count);
 		}
 
+		public ReceivedMessage ReceiveMessage()
+		{
+			return usock.RecvMsg ();
+		}
+
 		public override void Write (byte[] buffer, int offset, int count)
 		{
 			usock.Write (buffer, offset, count);
diff --git a/src/dbus-sharp.csproj b/src/dbus-sharp.csproj
index 28d264e..5ab9138 100644
--- a/src/dbus-sharp.csproj
+++ b/src/dbus-sharp.csproj
@@ -1,10 +1,10 @@
-<?xml version="1.0" encoding="Windows-1252"?>
+<?xml version="1.0" encoding="utf-8"?>
 <Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
     <ProjectGuid>{09A0200F-F3AF-4BD6-9EC4-E7D80D273E4C}</ProjectGuid>
-    <ProductVersion>9.0.30729</ProductVersion>
+    <ProductVersion>8.0.30703</ProductVersion>
     <SchemaVersion>2.0</SchemaVersion>
     <OutputType>Library</OutputType>
     <NoStandardLibraries>false</NoStandardLibraries>
@@ -13,7 +13,7 @@
     <RootNamespace>DBus</RootNamespace>
     <SignAssembly>true</SignAssembly>
     <AssemblyOriginatorKeyFile>..\dbus-sharp.snk</AssemblyOriginatorKeyFile>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.6</TargetFrameworkVersion>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>True</DebugSymbols>
@@ -83,6 +83,7 @@
     <Compile Include="Unix\UnixError.cs" />
     <Compile Include="Unix\UnixSocket.cs" />
     <Compile Include="AssemblyInfo.cs" />
+    <Compile Include="FileDescriptor.cs" />
   </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
   <ProjectExtensions>
